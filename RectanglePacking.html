<html>
<head>
<script>

function randInt( m, max ) {
/*
  randInt(max) // min = 0
  randInt(min, max)
  return random int in [min, max] (inclusive)
*/
  if (max == undefined) { max = m; m = 0 }
  return m + Math.floor(Math.random() * (max +1 - m))
}

function hardshrink( x, eps ) {
  if (eps == undefined) eps = 1e-12
  return (Math.abs(x) <= eps)? 0 : x
}

function round( x, d ) {
  if (d == undefined) d = 0
  const precision = 10**d;
  return Math.round(x *precision) /precision
}

</script>
<script>

var Tiles// = [11/16, 15/16, 15/16, 8/7, 7/5] // incorrectly calculated modified-ratio

// aspect-ratio = width/height
const defaultMinRatio = 9/16,
      defaultMaxRatio = 16/9
function generateTiles( N, minRatio = defaultMinRatio, maxRatio = defaultMaxRatio ) {
  if (Tiles == undefined) {
    Tiles = new Array(N)
    for (let i = 0; i < Tiles.length; i++) {
      const aspectRatio = minRatio + (maxRatio - minRatio) *Math.random()
      Tiles[i] = aspectRatio
    }
  }

  function createTile( aspectRatio, label ) {
    const div = document.createElement("div")
    document.body.appendChild(div)
    div.innerHTML = `<div class="label">${label}</div>`

    const style = div.style
    var color = '#'; for (let i = 0; i < 3; i++) color += randInt(8).toString(16)
    style.backgroundColor = color

    const tile = { div: div }
    tile.l = tile.t = 0
    tile.b = tile.h = 1
    tile.aspectRatio = tile.area = tile.r = tile.w = aspectRatio
    function update() {
      tile.r = tile.l + tile.w
      tile.b = tile.t + tile.h
      tile.area = tile.w * tile.h
      
      return tile
    }

    tile.moveTo = function( x, y ) {
      style.left = tile.l = x
      style.top  = tile.t = y
      return update()
    }
    tile.moveBy = function( x, y ) { return tile.moveTo(tile.l + x, tile.t + y) }
    tile.setWidth = function( w ) {
      style.width  = tile.w = w
      style.height = tile.h = w /aspectRatio
      return update()
    }
    tile.setHeight = function( h ) {
      style.width  = tile.w = h *aspectRatio
      style.height = tile.h = h
      return update()
    }
    tile.scale = function( s ) {
      tile.moveTo(tile.l *s, tile.t *s)
      return tile.setWidth(tile.w *s)
    }

    return tile
  }

  var Aspects = '['
  for (let i = 0; i < Tiles.length; i++) {
    let aspectRatio = Tiles[i]
    let m1, n1, d1 = Infinity
    for (let m = 1; m <= 16; m++) {
      for (let n = 1; n <= 16; n++) {
        const d = Math.abs(m/n - aspectRatio)
        if (d1 > d) { d1 = d, m1 = m, n1 = n }
      }
    }
    const label = `${i}<br>${m1}:${n1}`
    aspectRatio = m1/n1
    Aspects += `${m1}/${n1}, `

    Tiles[i] = createTile(aspectRatio, label)
  }
  console.log(Aspects.slice(0, -2) + ']' + "\n\n")
}

function centerTiles() {
  var left = Infinity, right  = -Infinity,
      top  = Infinity, bottom = -Infinity

  for (let i = 0; i < Tiles.length; i++) {
    const tile = Tiles[i]
    if (left   > tile.l)   left = tile.l
    if (right  < tile.r)  right = tile.r
    if (top    > tile.t)    top = tile.t
    if (bottom < tile.b) bottom = tile.b
  }

  const sw = document.body.offsetWidth  / (right - left),
        sh = document.body.offsetHeight / (bottom - top)
  const s = ((sw < sh)? sw : sh)
  const dx = (document.body.offsetWidth  - (right + left) *s)/2,
        dy = (document.body.offsetHeight - (bottom + top) *s)/2

  for (let i = 0; i < Tiles.length; i++) { const tile = Tiles[i]
                                           tile.scale(s); tile.moveBy(dx, dy) }

  const layoutRatio = (right - left) / (bottom - top)
  return layoutRatio
}

var canModify = true
function setRectangularLayout( containerRatio ) {
  const t0 = Tiles[0]
  t0.moveTo(0, 0)
  
  var W = t0.w,
      H = t0.h,
      Batches = [{ i: 0, isAcross: null }]
  
  function placeTilesAcross( h, batch = 0 ) {
    var l = 0
    for (let j = Batches[batch].i; j < i; j++) {
      const tile = Tiles[j]
      tile.setHeight(h)
      tile.moveTo(l, H)
      l += tile.w
    }
  }
  function placeTilesDownward( w, batch = 0 ) {
    var t = 0
    for (let j = Batches[batch].i; j < i; j++) {
      const tile = Tiles[j]
      tile.setWidth(w)
      tile.moveTo(W, t)
      t += tile.h
    }
  }

  var i = 1, isAcross
  while (i < Tiles.length) {
    var w = Tiles[i].w,
        h = Tiles[i].h,
        aspectRatio = W / H

    const s = hardshrink(aspectRatio - containerRatio)
    isAcross = s > 0 || s == 0 && !isAcross
    Batches.unshift({ i: i, isAcross: isAcross })

    if (isAcross) { // place across
      aspectRatio = W / (W * h / w + H)
      if (hardshrink(aspectRatio - containerRatio) >= 0) i += 1
      else {
        while ((i += 1) < Tiles.length) {
          const dw = h * Tiles[i].w / Tiles[i].h
          aspectRatio = W / (W * h / (w + dw) + H)
          if (hardshrink(aspectRatio - containerRatio) > 0) break
          w += dw
        }
      }
      placeTilesAcross(h *= W / w)
      H += h
    }
    else { // place downward
      aspectRatio = (W + H * w / h) / H
      if (hardshrink(aspectRatio - containerRatio) <= 0) i += 1
      else {
        while ((i += 1) < Tiles.length) {
          const dh = w * Tiles[i].h / Tiles[i].w
          aspectRatio = (W + H * w / (h + dh)) / H
          if (hardshrink(aspectRatio - containerRatio) < 0) break
          h += dh
        }
      }
      placeTilesDownward(w *= H / h)
      W += w
    }

    if (canModify && i >= Tiles.length) {
      function isBetter( modifiedRatio, placeTiles ) {
        const isModifiedBetter = Math.abs(modifiedRatio - containerRatio) <
                                 Math.abs(  aspectRatio - containerRatio)
        return isModifiedBetter
      }

      const i0 = Batches[0].i, i1 = Batches[1].i
      let r = 0
      if (Batches[1].isAcross) {
        const _h = Tiles[i1].h
        W = 0; for (let j = i1; j < i0; j++) W += Tiles[j].w
        for (let j = i0; j < i; j++) r += Tiles[j].w / Tiles[j].h
        h = _h * W / (r * _h + W)
        const modifiedRatio = W / ((H -= _h) + h)
        if (isBetter(modifiedRatio)) placeTilesAcross(h, 1)
      }
      else {
        const _w = Tiles[i1].w
        H = 0; for (let j = i1; j < i0; j++) H += Tiles[j].h
        for (let j = i0; j < i; j++) r += Tiles[j].h / Tiles[j].w
        w = _w * H / (r * _w + H)
        const modifiedRatio = ((W -= _w) + w) / H
        if (isBetter(modifiedRatio)) placeTilesDownward(w, 1)
      }

      break
    }
  }
}

function init() {
  generateTiles(10)
  update()
}

function update() {
  const containerRatio = document.body.offsetWidth / document.body.offsetHeight
  setRectangularLayout(containerRatio)

  const layoutRatio = centerTiles()
  const ratioError = containerRatio / layoutRatio
  document.title = `Ratio Error: ${round(ratioError, 3)}`
console.log("container", containerRatio, "layout", layoutRatio, "error", ratioError)
}

</script>
<style>

body {
  margin: 0;
  padding: 0;
}

div {
  position: absolute;
  _border: 1px solid black;
  
  opacity: 0.5;
}

div.label {
  margin: 5px;
  color: white;
  font-size: 10px;
}

</style>
</head>
<body onload="init()" onresize="update()" onclick="update()">
</body>
</html>
